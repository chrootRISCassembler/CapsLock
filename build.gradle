/*
    Copyright (C) 2018 RISCassembler

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.
    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

import java.awt.Desktop
import java.nio.file.Files
import java.nio.file.LinkOption
import java.nio.file.Paths
import java.nio.file.StandardCopyOption
import java.nio.file.StandardOpenOption
import java.time.LocalDateTime
import java.util.zip.ZipEntry
import java.util.zip.ZipFile
import java.util.zip.ZipInputStream

group 'CapsLock'
version '3.3.1-SNAPSHOT'

apply plugin: 'java'
sourceCompatibility = 10
targetCompatibility = 10

apply plugin: "groovy"
compileGroovy.enabled = false

apply plugin: 'application'
mainClassName = 'capslock.capslock.main.CapsLock'
startScripts.enabled = false
distZip.enabled = false
distTar.enabled = false

apply plugin: 'com.github.johnrengelman.shadow'
startShadowScripts.enabled = false
shadowDistTar.enabled = false
shadowDistZip.enabled = false

repositories {
    mavenCentral()
    jcenter()

    flatDir{
        dirs 'lib'
    }
}

class PrivateLibDownload{
    private static final String GitHubRepository = 'https://github.com/chrootRISCassembler/dependence/raw/master/'
    String libName
    String libVersion
    String jarName(){libName + '-' + libVersion + '.jar'}
    def localJarPath(){Paths.get(System.getProperty("user.dir") + "/lib/" + jarName())}

    void downloadLibJar(){
        try {
            URL url = new URL(GitHubRepository + jarName())
            InputStream inStream = url.openStream()
            Files.copy(inStream, localJarPath(), StandardCopyOption.REPLACE_EXISTING)
            println "Download " + libName +  " succeeded"
        } catch (Exception ex) {
            println "Download " + libName + " failed"
            throw ex
        }
    }

    void downloadIfNotExist(){
        if(!Files.exists(localJarPath(), LinkOption.NOFOLLOW_LINKS))downloadLibJar()
    }
}

final fileChecker = new PrivateLibDownload()
fileChecker.libName = 'FileChecker'
fileChecker.libVersion = '1.1.1-SNAPSHOT'

final trivialLogger = new PrivateLibDownload()
trivialLogger.libName = 'TrivialLogger'
trivialLogger.libVersion = '2.0.0'

final gameInfo = new PrivateLibDownload()
gameInfo.libName = 'GameInfo'
gameInfo.libVersion = '2.2.0-SNAPSHOT'

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.github.jengelman.gradle.plugins:shadow:2.0.2'
    }
}



dependencies {
    compile group: 'org.json', name: 'json', version:  '+'
    compile group: 'net.java.jinput', name: 'jinput', version: '2.0.7'
    testCompile 'org.codehaus.groovy:groovy-all:2.4.15'
    testCompile 'org.spockframework:spock-core:1.0-groovy-2.4'
    testCompile group: "org.testfx", name: "testfx-core", version: "4.0.13-alpha"
    testCompile group: 'org.testfx', name: 'testfx-spock', version: '4.0.13-alpha'

    compile name: fileChecker.libName, version: fileChecker.libVersion
    compile name: trivialLogger.libName, version: trivialLogger.libVersion
    compile name: gameInfo.libName, version: gameInfo.libVersion
}

tasks.withType(JavaCompile){
    options.encoding = 'UTF-8'
}

processResources{
    exclude 'MainForm.*'
}

jar{
    manifest{
        attributes 'Main-Class': mainClassName
    }
    println version
}

shadowJar.doFirst {
    def buildInfoFile = new File(System.getProperty("user.dir") + '/src/main/resources/BuildInfo.txt')
    buildInfoFile.bytes = []
    buildInfoFile << 'version : ' + version + '\n'
    buildInfoFile << 'git_commit_hash : ' +  'git rev-parse HEAD'.execute().text.trim()  + '\n'
    buildInfoFile << 'date : ' + LocalDateTime.now()
}

task cpResources(type : Copy){
    exclude 'BuildInfo.txt'
    from 'src/main/resources'
    into 'build/classes/java/main/capslock/capslock/main'
}

shadowJar.dependsOn cpResources

task downloadJInputBinaries {
    final dependentBinaryDir = Paths.get(System.getProperty("user.dir") + "/dependentBinary/")
    if(Files.notExists(dependentBinaryDir)){
        Files.createDirectory(dependentBinaryDir)
    }
    if(Files.list(dependentBinaryDir).count() == 0) {
        println 'Native library isn\'t downloaded.\nDownloading ...'

        final downloadedZipPath = Paths.get(System.getProperty("user.dir") + "/dependentBinary/jinput.zip")

        try {
            URL url = new URL('http://ci.newdawnsoftware.com/job/JInput/lastBuild/artifact/dist/jinput_nightly_20160318.zip')
            InputStream inStream = url.openStream()
            Files.copy(inStream, downloadedZipPath, StandardCopyOption.REPLACE_EXISTING)
            println "Download succeeded."
        } catch (Exception ex) {
            println "Download failed."
            throw ex
        }

        println 'uncompress zip ...'

        byte[] buf = new byte[1024]
        final ZipInputStream zipInputStream = new ZipInputStream(Files.newInputStream(downloadedZipPath))
        for (ZipEntry entry = zipInputStream.getNextEntry(); entry != null; entry = zipInputStream.getNextEntry()) {
            if (entry.isDirectory()) continue
            if (entry.getName().endsWith(".jar")) continue

            println 'uncompress : ' + entry.getName()
            final originalFileName = Paths.get(entry.getName()).getFileName()
            final uncompressed = Paths.get(dependentBinaryDir.toString() + '/' + originalFileName)
            final OutputStream outputStream = Files.newOutputStream(uncompressed,
                    StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE)
            while (true) {
                final int len = zipInputStream.read(buf)
                if (len < 0) break
                outputStream.write(buf, 0, len)
            }
            outputStream.close()
        }
        zipInputStream.close()

        println 'uncompress done'

        Files.delete(downloadedZipPath)
    }
}

run {
    systemProperties.put("java.library.path", Paths.get(System.getProperty("user.dir") + "/dependentBinary/").toAbsolutePath())
    dependsOn downloadJInputBinaries, cpResources
    println("Current directory is " + workingDir)
    workingDir = '../TestEnv'
    println("cd to the testing environment : " + workingDir)
}

compileJava {
    dependsOn downloadJInputBinaries

    doFirst {
        def libDir = Paths.get(System.getProperty("user.dir") + "/lib/")
        if (Files.notExists(libDir)) {
            Files.createDirectory(libDir)
        }

        fileChecker.downloadIfNotExist()
        trivialLogger.downloadIfNotExist()
        gameInfo.downloadIfNotExist()
    }
}

task forceUpdateLib{
    doLast {
        def libDir = Paths.get(System.getProperty("user.dir") + "/lib/")
        if (Files.notExists(libDir)) {
            Files.createDirectory(libDir)
        }
        fileChecker.downloadLibJar()
        trivialLogger.downloadLibJar()
        gameInfo.downloadLibJar()
    }
}

javadoc {
    options.charSet = 'UTF-8'
    options.encoding = 'UTF-8'
    options.links "https://docs.oracle.com/javase/10/docs/api/"

    doLast{
        //デフォルトブラウザで生成したjavadocを自動で開く
        def userDir = System.getProperty("user.dir")
        def indexURI = new URI(userDir.replace('\\', '/') + "/build/docs/javadoc/index.html")
        Desktop.getDesktop().browse(indexURI)
    }
}